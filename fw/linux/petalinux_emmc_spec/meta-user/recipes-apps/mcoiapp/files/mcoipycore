#!/usr/bin/env python3

import os
import smbus
import logging as log
import time
import mmap
import re

log.basicConfig(format='%(asctime)s %(levelname)s: %(message)s',
        datefmt='%m/%d/%Y %I:%M:%S %p',level=log.INFO)

# for more info, how to use mmap in python
# https://support.xilinx.com/s/article/1171977?language=en_US

# PS GPIO
# GPIO_BASEADDRESS = 0xFF0A0000

# AXI GPIO
GPIO_BASEADDRESS = 0x0080010000
GPIO_DIR_ADDRESS = GPIO_BASEADDRESS + 0x4

MAP_MASK = mmap.PAGESIZE - 1

class smbus_i2c_api:

    def __init__(self, i2c, address: int) -> None:
        self.i2c = i2c
        self.address = address

    def read_byte_data(self, reg: int) -> int:
        return self.i2c.read_byte_data(self.address, reg)

    def write_byte_data(self, reg: int, val: int):
        self.i2c.write_byte_data(self.address, reg, val)

class si5338b_loader:

    def __init__(self, i2c_api, register_map_file):
        self._bus = i2c_api
        self.reg_file = register_map_file
        # check if the device is there

    def set_bits(self, reg, val):
        current_reg = self._bus.read_byte_data(reg)
        log.debug(bin(current_reg))
        self._bus.write_byte_data(reg, current_reg | val)
        log.debug(bin(self._bus.read_byte_data(reg)))

    def clear_bits(self, reg, val):
        current_reg = self._bus.read_byte_data(reg)
        log.debug(bin(current_reg))
        self._bus.write_byte_data(reg, current_reg & ~val)
        log.debug(bin(self._bus.read_byte_data(reg)))

    def copy_bits(self, reg0, reg1, mask):
        current_reg0 = self._bus.read_byte_data(reg0)
        current_reg1 = self._bus.read_byte_data(reg1)

        current_reg1_new = current_reg1 | (current_reg0 & mask)
        self._bus.write_byte_data(reg1, current_reg1_new)
        log.debug('{0} => {1} = {2}))'.format(current_reg0,
            current_reg1, current_reg1_new))

    def parse_config(self):
        p = re.compile(r'''{\s*(?P<reg>\d*),
                           (0x|\s*)(?P<val>[\d\w]*),
                           (0x|\s*)(?P<mask>[\d\w]*).*''',
                           re.DOTALL | re.VERBOSE | re.MULTILINE)

        with open(self.reg_file, 'r+') as regs:
            return [re.match(p, line).groupdict() for line in regs if line[0] == '{']

    def write_new_config(self):
        config = self.parse_config()
        for c in config:
            imask = int(c['mask'], 16) # register mask
            ireg = int(c['reg'], 10) # register position
            ival = int(c['val'], 16) # register variable
            if(imask == 0xff):
                self._bus.write_byte_data(ireg, ival)
                log.info('reg: {0}, _ => {1} | reg value: {2}'.format(ireg,
                ival, self._bus.read_byte_data(ireg)))
            else:
                current_reg = self._bus.read_byte_data(ireg)
                clear_cur_val = (current_reg & ~imask)
                clear_new_val = ival & imask
                combined = clear_cur_val | clear_new_val
                self._bus.write_byte_data(ireg, combined)
                log.info('reg: {0}, {1} => {2} | reg value: {3}'.format(ireg,
                current_reg, combined, self._bus.read_byte_data(ireg)))

    def get_alarms(self):
        si5338_status_reg = 218
        return self._bus.read_byte_data(si5338_status_reg)

    def validate_value(self):
        while((self.get_alarms() & 0x10) or (self.get_alarms() & 0x11)):
            pass

    def program(self):
        log.info('disabling outputs')
        self.set_bits(231, 0x10) #disable outputs

        log.info('lol pause')
        self.set_bits(241, 0x80) #pause lol

        log.info('writing config')
        self.write_new_config()

        log.info('validating input clock ...')
        alarms = self.get_alarms()
        if alarms & 0x04:
            log.warning('LOS_CLKIN is active.')
        if alarms & 0x08:
            log.warning('LOS_FDBK is active.')

        self.clear_bits(49, 0x80) #configure pll for locking
        self.set_bits(246, 0x02) #initiate locking of ppl

        time.sleep(0.025) #wait 25ms

        self.clear_bits(241, 0x80) #restart lol
        self.set_bits(241, 0x65)

        log.info('waiting for locking pll ...')
        self.validate_value()
        log.info('ok')

        log.info('copying registers')
        self.copy_bits(237, 47, 0x03)
        self.copy_bits(236, 46, 0xff)
        self.copy_bits(235, 45, 0xff)

        self.set_bits(47, 0x14)
        self.set_bits(49, 0x80) #set pll to use fcal

        # if using down-spread
        # self.set_bits(226, 0x02)
        # time.sleep(0.01)
        # self.clear_bits(226, 0x02)

        log.info('enabling outputs')
        self.clear_bits(230, 0x10) #enable outputs
        log.info('done')



def read_addr(mem, addr, length):
    global MAP_MASK
    mem.seek(addr & MAP_MASK)
    #print mem.size()
    val = 0x0
    for i in range(length):
        a = mem.read_byte()
        val |= a << (i * 8)
    return val

def write_addr(mem, addr, value, length):
    global MAP_MASK
    mem.seek(addr & MAP_MASK)
    value_hex = hex(value)
    aligned_hex = f'{value:0{length*2}x}'
    a = bytearray.fromhex(aligned_hex)
    mem.write(a)

def read(addr, length=4):
    f = os.open("/dev/mem", os.O_RDWR | os.O_SYNC)
    mem = mmap.mmap(f, mmap.PAGESIZE, mmap.MAP_SHARED, mmap.PROT_READ | mmap.PROT_WRITE,offset=addr & ~MAP_MASK)
    #print (mem, hex(addr))
    val = read_addr(mem, addr, length)
    mem.close()
    os.close(f)
    return val

def write(addr, value, length=4, mask=0xffffffff):
    f = os.open("/dev/mem", os.O_RDWR)
    #print "/dev/mem opened"
    mem = mmap.mmap(f, mmap.PAGESIZE, mmap.MAP_SHARED, mmap.PROT_READ | mmap.PROT_WRITE, offset=addr & ~MAP_MASK)
    # read old value
    value_no_hex_prefix = f'{value:0{length*2}x}'
    ba = bytearray.fromhex(value_no_hex_prefix)
    ba.reverse() # reverses byte order
    reversed_value  = int(''.join(format(x, '02x') for x in ba), 16)
    # print(f'reversed value: {reversed_value:8x}')
    readValue = read_addr(mem, addr, length)
    # apply mask
    maskedValue = reversed_value | (readValue & ~mask)
    # write new value
    write_addr(mem, addr, maskedValue, length)
    # read new value
    newValue = read_addr(mem, addr, length)
    mem.close()
    os.close(f)
    return newValue

if __name__ == '__main__':
    # USER SETUP
    # here you write the path to your generated c file
    reg_file = '/etc/mcoi_config/mcoi_xu5_devkit_ch1_ch2_120mhz_low_jitter_on_1ch_25mhz_ref_lvds_clk_source1_in5_in6_from_pcb_rev1.h'

    # 7 bit address
    DEVICE_ADDRESS = 0x70

    i2c = smbus.SMBus(0) # 0 = /dev/i2c-0 (I2C0)
    bus = smbus_i2c_api(i2c, DEVICE_ADDRESS)

    pll = si5338b_loader(bus, reg_file)

    pll.program()

    a = read(GPIO_DIR_ADDRESS)
    print(hex(a))

    write(GPIO_DIR_ADDRESS, 0xffff0000)

    a = read(GPIO_DIR_ADDRESS)
    print(hex(a))

    # unblock hdl design
    write(GPIO_BASEADDRESS, 0x4)

    a = read(GPIO_BASEADDRESS)
    print(hex(a))

