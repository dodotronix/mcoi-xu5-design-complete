---
-- TODO LICENSE
-- Petr Pacner | CERN | 2021-10-19 Tue 17:27 PM     
-- description:
--              This test send data using I2cReader to i2cSlave and if the 
--              received data matches send byte the test pass. It does the 
--              same procedure with receiving data. The testbench ask for
--              value of certain register and the slave send it to I2cReader.
--              Test is complete if both Read/Write pass the transition test.
---

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_textio.all;

-- this lib is used by 3rd party i2c slave
library std;
use std.textio.all;

-- Vunit libs  
library vunit_lib;
context vunit_lib.vunit_context;

entity I2cReader_tb is
  generic(runner_cfg : string);
end I2cReader_tb;

architecture behavioral of I2cReader_tb is
constant PERIOD: time := 142.86 ns;
constant SLVADDR: std_logic_vector(6 downto 0) := "1110000";

-- Components declarations
component I2C_slave
  generic (SLAVE_ADDR : std_logic_vector(6 downto 0));
  port (
         scl              : inout std_logic;
         sda              : inout std_logic;
         clk              : in    std_logic;
         rst              : in    std_logic;
         -- User interface
         read_req         : out   std_logic;
         data_to_master   : in    std_logic_vector(7 downto 0);
         data_valid       : out   std_logic;
         data_from_master : out   std_logic_vector(7 downto 0));
end component;

-- Generic master I2c peripheral
component I2cMasterGeneric 
  generic(g_CycleLenght : std_logic_vector(9 downto 0));
  port(
        Clk_ik          : in std_logic;
        Rst_irq         : in std_logic;
        SendStartBit_ip : in std_logic;
        SendByte_ip     : in std_logic;
        GetByte_ip      : in std_logic;
        SendStopBit_ip  : in std_logic;
        Byte_ib8        : in std_logic_vector(7 downto 0);
        AckToSend_i     : in std_logic;
        Byte_ob8        : out std_logic_vector(7 downto 0);
        AckReceived_o   : out std_logic;
        Done_o          : out std_logic;

        Scl_ioz         : inout std_logic;
        Sda_ioz         : inout std_logic);
end component;

-- I2creader
component I2cReader
port(
        clk  : in std_logic;
        rstp : in std_logic;

        -- i2c master generic
        Done_i         : in std_logic;
        AckReceived_i  : in std_logic;
        SendStartBit_o : out std_logic;
        SendByte_o     : out std_logic;
        GetByte_o      : out std_logic;
        SendStopBit_o  : out std_logic;
        AckToSend_o    : out std_logic;
        Byte_ib8       : in std_logic_vector(7 downto 0);
        Byte_ob8       : out std_logic_vector(7 downto 0);

        -- data ports to reader
        Data_i16b : in std_logic_vector(15 downto 0);
        Data_o8b  : out std_logic_vector(7 downto 0);

        -- Reader IOs
        Rw_i         : in std_logic;
        Ready_o      : out std_logic;
        Valid_i      : in std_logic;
        Dev_addr_i7b : in std_logic_vector(6 downto 0));
end component;

signal clk: std_logic := '0';
signal rst: std_logic;

signal scl_io: std_logic := 'H';
signal sda_io: std_logic := 'H';

-- I2c Master Control signals
signal send_startb      : std_logic;
signal send_byte        : std_logic;
signal get_byte         : std_logic;
signal send_stopb       : std_logic;
signal send_ack         : std_logic;
signal byte_from_i2c    : std_logic_vector(7 downto 0);
signal byte_to_i2c      : std_logic_vector(7 downto 0);
signal data_to_reader   : std_logic_vector(15 downto 0);
signal data_from_reader : std_logic_vector(7 downto 0);

-- I2c Reader User control 
signal rw       : std_logic;
signal rdy      : std_logic;
signal rdy_cc   : std_logic;
signal valid    : std_logic;
signal done     : std_logic;
signal ack_recv : std_logic;

-- I2c slave signals --
signal data_valid       : std_logic;
signal data_valid_cc    : std_logic;
signal data_from_master : std_logic_vector(7 downto 0);
signal data_to_master   : std_logic_vector(7 downto 0);
signal read_req         : std_logic;

-- test bench signals 
signal finished: std_logic;

begin
  
  -- simalation
  stimulus: process begin
    -- start vunit testbench
    test_runner_setup(runner, runner_cfg);

    rst <= '1';
    wait for PERIOD*10;
    rst  <= '0';
    wait for PERIOD*2;
    wait until rising_edge(finished);

    report "Calling 'finish'";
    test_runner_cleanup(runner); -- Simulation ends 
  end process stimulus;

  -- testbench clock source
  clk <= not clk after PERIOD/2;

  -- initial values for data and read/write signal on DUT
  data_to_master <= x"00";
  data_to_reader <= x"0202";
  rw <= '1';

  -- emulation of present i2c
  test: process begin
    data_valid <= '0';
    set_timeout(runner, 200 ns);
    wait for 100 ns;
    data_valid <= '1';
  end process test;

  -- this block waits for signal on I2c slave. if the signal goes high
  -- simulation stops
  received_byte: process(clk) begin
    if rising_edge(clk) then
      if(rst = '1') then
        finished <= '0';
      else
        rdy_cc <= rdy;
        data_valid_cc <= data_valid;
        valid <= '0';
        if (rdy = '1' and rdy_cc = '1') then
          valid <= '1';
        elsif (data_valid = '1' and data_valid_cc = '0') then
          finished <= '1';
        end if;
      end if;
    end if;
  end process received_byte;

  -- I2cReader instance (DUT)
  --i2c_reader_i: I2cReader
  --port map(clk                      => clk,
           --rstp                     => rst,
           --Done_i                   => done,
           --AckReceived_i            => ack_recv,
           --SendStartBit_o           => send_startb,
           --SendByte_o               => send_byte,
           --GetByte_o                => get_byte,
           --SendStopBit_o            => send_stopb,
           --AckToSend_o              => send_ack,
           --Byte_ib8                 => byte_from_i2c,
           --Byte_ob8                 => byte_to_i2c,
           --Data_i16b(15 downto 0)   => data_to_reader,
           --Data_o8b(7 downto 0)     => data_from_reader,
           --Rw_i                     => rw,
           --Ready_o                  => rdy,
           --Valid_i                  => valid,
           --Dev_addr_i7b(6 downto 0) => SLVADDR);

  -- I2c Master instance
  --i2c_driver_i: I2cMasterGeneric
  --generic map(g_CycleLenght     => "00" & x"07") -- divide by 9 for freq 7Mhz
  --port map(Clk_ik               => clk,
           --Rst_irq              => rst,
           --SendStartBit_ip      => send_startb,
           --SendByte_ip          => send_byte,
           --GetByte_ip           => get_byte,
           --SendStopBit_ip       => send_stopb,
           --AckToSend_i          => send_ack,
           --Byte_ib8(7 downto 0) => byte_to_i2c,
           --Byte_ob8(7 downto 0) => byte_from_i2c,
           --AckReceived_o        => ack_recv,
           --Done_o               => done,
           --Scl_ioz              => scl_io,
           --Sda_ioz              => sda_io);

  -- I2c Slave instance 
  --i2c_slave_i: I2C_slave
  --generic map(
  --SLAVE_ADDR                            => SLVADDR)
  --port map(scl                          => scl_io,
           --sda                          => sda_io,
           --clk                          => clk,
           --rst                          => rst,
           --read_req                     => read_req,
           --data_to_master(7 downto 0)   => data_to_master,
           --data_valid                   => data_valid,
           --data_from_master(7 downto 0) => data_from_master);

  scl_io <= 'H';
  sda_io <= 'H';

end architecture;
